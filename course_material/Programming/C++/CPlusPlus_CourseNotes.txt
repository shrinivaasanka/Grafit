##############################################################################################################################################
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
##############################################################################################################################################
Course Authored By:
-----------------------------------------------------------------------------------------------------------
Srinivasan Kannan
(also known as: Shrinivaasan Kannan, Shrinivas Kannan)
Ph: 9791499106, 9003082186
Krishna iResearch Open Source Products Profiles:
http://sourceforge.net/users/ka_shrinivaasan,
https://github.com/shrinivaasanka,
https://www.openhub.net/accounts/ka_shrinivaasan
Personal website(research): https://sites.google.com/site/kuja27/
emails: ka.shrinivaasan@gmail.com, shrinivas.kannan@gmail.com,
kashrinivaasan@live.com
-----------------------------------------------------------------------------------------------------------
##############################################################################################################################################

This is a non-linearly organized, code puzzles oriented, continually updated set of course notes on C++ language. This
complements NeuronRain course materials on Linux Kernel, Cloud, BigData Analytics and Machine Learning and covers
fundamentals of C++.
----------------------------------------------------------------------------------------------------------------------------

22 February 2017
----------------
An example on C++ templates and Runtime type identification:
------------------------------------------------------------
Example code snippet in code/templates.cpp implements a simple templatized book class with book type string as template parameter. Template
book is instantiated with template and typename keywords and type T can be any subject type passed in as template parameter. Template class
EBook derives from base class Book<T>. A subtlety in this example is absence of default constructor for Book<T> causes following compiler 
error:

g++ -g -o templates -I/usr/local/include -L/usr/local/lib -std=c++14 *.cpp
templates.cpp: In instantiation of ‘EBook<T>::EBook(T) [with T = std::__cxx11::basic_string<char>]’:
templates.cpp:47:28:   required from here
templates.cpp:36:2: error: no matching function for call to ‘Book<std::__cxx11::basic_string<char> >::Book()’
  {
  ^
templates.cpp:18:2: note: candidate: Book<T>::Book(T) [with T = std::__cxx11::basic_string<char>]
  Book(T type)
  ^
templates.cpp:18:2: note:   candidate expects 1 argument, 0 provided
templates.cpp:8:7: note: candidate: Book<std::__cxx11::basic_string<char> >::Book(const Book<std::__cxx11::basic_string<char> >&)
 class Book
       ^
templates.cpp:8:7: note:   candidate expects 1 argument, 0 provided
templates.cpp:8:7: note: candidate: Book<std::__cxx11::basic_string<char> >::Book(Book<std::__cxx11::basic_string<char> >&&)
templates.cpp:8:7: note:   candidate expects 1 argument, 0 provided

-----------------------------------------------------------------------------------------------------
Adding default constructor:
	Book()
        {
        }
removes compilation error and following is printed:
---------------------------------------------------
Instantiating Book of type Maths
template type:NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
Instantiating Book of type ComputerScience
template type:NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
Instantiating Book of type Physics
template type:NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
Instantiating Book of type History
template type:NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
Instantiating EBook of type English
Read book
Read book
Read book
Read book
Read book
-----------------------------------------------------------------
In above example, read_book() is a virtual function in superclass Book which can be overridden in derived classes. Previous output indicates
how dynamic polymorphism works and read_book() of Book<T> is invoked from derived class EBook<T>. Type information is printed by typeid keyword of C++. This example is built using G++ with C++14 standard compiler option.

--------------------------------------------------------------------
17 July 2017
--------------------------------------------------------------------
Question: How can a program print its source itself as output ? [Quine - self-aware code]

Answer: Theoretically, there exists a lambda function with a fixed point i.e f(x)=x. Unix/Linux binaries are stored in ELF format which have debugging information embedded in DWARF entries (as set of DIEs - Debugging Information Entries). There are utilities like objdump and dwarfdump which display the DIEs. For example, following is the DWARF dump of asfer executable pointing to the compilation source directory in DW_AT_comp_dir:

root@Inspiron-1545:/media/shrinivaasanka/6944b01d-ff0d-43eb-8699-cca469511742/home/shrinivaasanka/Krishna_iResearch_OpenSource/GitHub/asfer-github-code/cpp-src# objdump --dwarf=info asfer |more

asfer:     file format elf32-i386

Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x16f7e (32-bit)
   Version:       4
   Abbrev Offset: 0x0
   Pointer Size:  4
 <0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)
    <c>   DW_AT_producer    : (indirect string, offset: 0x35560): GNU C++14 5.2.1 20151010 -mtune=generic -march=i686 -g -std=c++14 -fstack-pro
tector-strong
    <10>   DW_AT_language    : 4	(C++)
    <11>   DW_AT_name        : (indirect string, offset: 0xe304): DecisionTreeClassifier.cpp
    <15>   DW_AT_comp_dir    : (indirect string, offset: 0x7933): /media/shrinivaasanka/0fc4d8a2-1c74-42b8-8099-9ef78d8c8ea24/home/kashrinivaasan/KrishnaiResearch_OpenSource/GitHub/asfer-github-code/cpp-src
    <19>   DW_AT_ranges      : 0x210
    <1d>   DW_AT_low_pc      : 0x0
    <21>   DW_AT_stmt_list   : 0x0

There are libdwarf libraries for programmatically querying ELF DWARF DIEs. Thus a wrapper reflection code invoking the dwarfdump on executable can be written to print the source(assumes fresh compilation everytime).

-------------------------------------------------------------------
12 September 2017
-------------------------------------------------------------------
Question: Remove duplicates in a string in-place (no extra space) e.g shrink aabbcba to abc

Answer: One possible solution is to sort the string (by an in place sorting algorithm like quicksort) in ascending order of unicode value e.g aabbcba is sorted to aaabbbc. Implement the string as linked-list of literals, Scan the string linked list and remove repetitive alphabets and repeat till duplicates are removed. Code example for this is at code/remove_duplicates.cpp uses STL string sort() to sort the string, STL erase() to simulate a linked list node erasure, and shows how STL iterators for strings begin() and end() are applied. 
---------------------------------------------------
str:9aaabbbcccddddddddeeeffggjjksss
str:9aaabbbcccddddddddeeeffggjjksss
str:9aaabbbcccddddddddeeeffggjjksss
str:9aabbbcccddddddddeeeffggjjksss
str:9aabbbcccddddddddeeeffggjjksss
str:9aabbcccddddddddeeeffggjjksss
str:9aabbcccddddddddeeeffggjjksss
str:9aabbccddddddddeeeffggjjksss
str:9aabbccddddddddeeeffggjjksss
str:9aabbccdddddddeeeffggjjksss
str:9aabbccddddddeeeffggjjksss
str:9aabbccdddddeeeffggjjksss
str:9aabbccddddeeeffggjjksss
str:9aabbccddddeeffggjjksss
str:9aabbccddddeeffggjjksss
str:9aabbccddddeefggjjksss
str:9aabbccddddeefgjjksss
str:9aabbccddddeefgjksss
str:9aabbccddddeefgjksss
duplicateexists(): true
str:9aabbccddddeefgjkss
str:9aabbccddddeefgjkss
str:9aabbccddddeefgjkss
str:9aabbccddddeefgjkss
str:9abbccddddeefgjkss
str:9abccddddeefgjkss
str:9abcddddeefgjkss
str:9abcdddeefgjkss
str:9abcddeefgjkss
str:9abcddefgjkss
str:9abcddefgjkss
str:9abcddefgjkss
str:9abcddefgjkss
str:9abcddefgjkss
str:9abcddefgjks
str:9abcddefgjks
str:9abcddefgjks
str:9abcddefgjks
str:9abcddefgjks
str:9abcddefgjks
str:9abcdefgjks
str:9abcdefgjks
str:9abcdefgjks
str:9abcdefgjks
str:9abcdefgjks

---------------------------------------------------------------------------------------
2 October 2017 - Placement New and Operator Overloading
---------------------------------------------------------------------------------------
C++ provides mechanisms to override default storage allocation by overloading operator new. There are two types of operator new(): Plain overload and Placement Overload. Placement new supplies storage as argument to operator new. Code example in code/placement_new.cpp illustrates this
as below (this has been compiled to C++2017 standard). Older ways of overriding pointer this have been described in comments. Recent compilers
do not allow direct *this overrides and prefer operator new. Operator new facility is useful for writing new storage allocators and memory debuggers which can instrument and bypass default memory allocation for profiling. This example also explains the rvalue reference operator && for *this. Rvalue references alias the right side of an assignment while Lvalue references(&) alias the left side of assignment. 
=====================================
auto allocation
=====================================
this...0xffa08a90
overwriting this...
rvaluethis :0xffa08a90
=====================================
operator new:
=====================================
operator new overloaded and this is from a heap allocator
this...0x96a3e18
overwriting this...
rvaluethis :0x96a3e18
operator delete overloaded and this is freed to a heap allocator
=====================================
placement operator new:
=====================================
this...0xffa08aa8
overwriting this...
rvaluethis :0xffa08aa8

