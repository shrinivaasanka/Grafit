##############################################################################################################################################
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.
##############################################################################################################################################
Course Authored By:
-----------------------------------------------------------------------------------------------------------
Srinivasan Kannan
(also known as: Shrinivaasan Kannan, Shrinivas Kannan)
Ph: 9791499106, 9003082186
Krishna iResearch Open Source Products Profiles:
http://sourceforge.net/users/ka_shrinivaasan,
https://github.com/shrinivaasanka,
https://www.openhub.net/accounts/ka_shrinivaasan
Personal website(research): https://sites.google.com/site/kuja27/
emails: ka.shrinivaasan@gmail.com, shrinivas.kannan@gmail.com,
kashrinivaasan@live.com
-----------------------------------------------------------------------------------------------------------
##############################################################################################################################################

This is a non-linearly organized, continually updated set of course notes on miscellaneous topics in Computer Science (algorithms,
datastructures, graph theory etc.,). Puzzles/Problems/Questions are sourced from many text books.
----------------------------------------------------------------------------------------------------------------------------
---------------
9 February 2017
---------------
A graph G with 100 vertices numbered from 1 to 100 has edges between vertices p and q iff p-q=8 or p-q=12. Number of connected components
of G is:

Number of components of an undirected graph is number of subgraphs with no path between them. Above set of adjacent vertices can be written as merger of 2 arithmetic progressions of common different 8 and 12 as below:
	1,9,13,17,25,33,37,41,49,...
	2,10,14,18,26,34,38,42,50,...
	3,11,15,19,27,35,39,43,51,...
	4,12,16,20,28,36,40,44,52,...
	5,13,17,21,29,37,41,45,53,...
	6,14,18,22,30,38,42,46,54,...
	7,15,19,23,31,39,43,47,55,...
	8,16,20,24,32,40,44,48,56,...
Further sets are repetitions of the above. Of the previous 8 sets 4 have common elements between them and form a connected component. Thus there are 4 connected components in the graph G. This is equal to GCD of two common differences 4 and 8.

-----------------
15 February 2017
-----------------
Linear Programming and Simplex
-------------------------------
Linear programming is defined as: Given an objective function to minimize or maximize with set of constraints expressed as inequalities, finding set of solutions which maximize or minimize the objective function. For example following is a linear program:

	maximize x1 + 6x2 = P (written as -x1-6x2+P = 0)
	subject to constraints:
		2x1 + x2 <= 10
		x1 + 5x2 <= 9
There are 3 types of solutions possible for a Linear Program:
	*) Basic feasible solution - which is the set of vectors which satisfy the constraints. There are two types of feasible solutions:
		*) Bounded feasible - the satisfying vectors maximize the objective function to a bounded value
		*) Unbounded feasible - the satisfying vectors maximize the objective function to an unbounded value
	*) Infeasible - there are no vectors which satisfy the constraints.

Simplex algorithm solves an LP in following tableau steps:

while (there are no negative indicators in ObjF row)
{
*) Choose least positive pivot row and most negative pivot column as pivots:
		- most negative indicator column is chosen as pivot column
		- divide the last column entries by pivot column entries and choose least positive row as pivot row

			x1 	x2 	s1 	s2	P
		c1	2	1	1	0	0	10	10/1 = 10
		c2	1	5	0	1	0	9	9/5 = 1.8 (least positive pivot row - c2)
		----------------------------------------------------
		ObjF	-1	-6	0	0	1	0
		----------------------------------------------------
				most negative pivot column (x2)

*) the pivot entry in the intersection of c2 and x2 is 5. Interchanging the row and column variables row2 is x2. Divide by pivot to obtain 1:

			x1 	c2 	s1 	s2	P
		c1	2	1	1	0	0	10
		x2	1/5	5/5	0	1/5	0	9/5
		----------------------------------------------------
		ObjF	-1	-6	0	0	1	0
		----------------------------------------------------
and do row operations till all other row entries in pivot column are zero.

*) perform a row mapping operation - Rc1 = Rc1 - Rx2:

			x1 	c2 	s1 	s2	P
		c1	9/5	0	1	-1/5	0	41/5
		x2	1/5	1	0	1/5	0	9/5
		----------------------------------------------------
		ObjF	-1	-6	0	0	1	0
		----------------------------------------------------

*) perform a row mapping operation - RObjF = 6Rx2 + RObjF:

			x1 	c2 	s1 	s2	P
		c1	9/5	0	1	-1/5	0	41/5
		x2	1/5	1	0	1/5	0	9/5
		----------------------------------------------------
		ObjF	1/5	0	0	6/5	1	54/5	(no negative indicators, iteration stops)
		----------------------------------------------------
}

From previous last iteration feasible solution satisfying the constraints is :
	x2=9/5 , x1=0 and maximized objective function value is 54/5 for x1 + 6x2 = P
------------------------------------------------------------------------------------------------------------------------------
LL,LR and Shift-Reduce Parsers
------------------------------------------------------------------------------------------------------------------------------
Parsing with reference to modern programming languages is defined as:
Given a set of Context Free Grammar Production Rules produce a parse tree in either top-down or bottom-up fashion resulting in a
single non-terminal symbol.

LL parsing is Left-Right, Top-Down scanning of the symbols with Leftmost Derivation  while LR parsing is Left-Right, Bottom-Up scanning of the
symbols with Rightmost Derivation. Shift-reduce parsing which is an LR parsing is implemented with a stack,lookahead symbol(usually 1) and yet to be scanned set of terminals.

Leftmost Derivation applies production rule to leftmost non-terminal in a sentential form(top-down parsing). Rightmost Derivation applies a production rule to rightmost non-terminal in a sentential form(bottom-up parsing)

Example CFG for simple arithmetic operation (+ and *):
	E = E * T
	T = E + E
	E = id

Previous CFG is applied to parse a sentence:
	x * x + x

Leftmost Bottom-Up Derivation Parser:
	x * x + x
	E = E * T
	E = id * T (E = id)
	E = id * E + E (T = E + E)
	E = id * id + E (E = id)
	E = id * id + id (E = id)

Rightmost Top-Down Derivation Parser (Complete Reversal of Previous Parsing Steps):
	E = E * T
	E = E * E + E (T = E + E)
	E = E * E + id (E = id)
	E = E * id + id (E = id)
	E = id * id + id (E = id)

Bottom-Up Shift-Reduce Parsing with a stack for previous Rightmost Derivation:
	Stack			Lookahead		Yet-to-be-scanned	ProductionRule
	-			id			* id + id		-			(Shift)
	E			*			* id + id		E = id			(Reduce)
	E			*			id + id			-			(Shift)
	E*			id			+ id			E = id			(Reduce)
	E*E			+			id			-			(Reduce)
	E*E			+			id			-			(Shift)
	E*E+			id			-			E = id			(Reduce)
	E*E+E			-			-			T = E + E		(Reduce)
	E*T			-			-			E = E * T		(Reduce)
	E			-			-			-			-

Shift-Reduce parser actions at each step are determined by valid combinations of top of the stack and the lookahead - a pushdown automaton state diagram. Shift step advances to next unscanned symbol and Reduce step applies a production to top of the stack based on lookahead.

------------------------------------------------------------------------------------------
23 February 2017
------------------------------------------------------------------------------------------
Evaluate prefix expression:
	*+3+3^3+333

This can be evaluated with two stacks as below by popping topmost and storing it in another stack, evaluating next two operands and operator on first stack and pushing back the result and topmost popped from second stack to first stack:
	3		3		3		3		3		=  2205
	3		6		729		732		735
	3		3		3		3		*
	+		^		+		+
	3		3		3		*
	^		+		+
	3		3		*
	+		+
	3		*
	+
	*
------------------------------------------------------------------
An egg dropped from a floor between 1 to 100 breaks if floor value is x or above. With 2 eggs find minimum number of drops required to find
the highest floor from which egg does not break.

Binary search on the floors 1 to 100 would require log(100) eggs. With 2 eggs binary search won't work. For this number 100 is split into
intervals of powers of 2 (this is the idea behind logarithmic counters) - 2,4,16,32,64. First egg is dropped sequentially from 2,4,16,32,64th
floors. Drop when first egg breaks is denoted as m. Maximum number of drops is 6 for first egg. Then the second egg is sequentially dropped from 2^(m-1) floor to 2^m floor which is equal to 2^(m-1). Thus total drops required is m + 2^(m-1). For maximum value of m=6, this is 6 + 36=42 . Thus with 42 drops, highest floor from where egg does not break can be found. Trivial one level binary search would require 50 (100/2) drops for second egg.
-------------------------------------------------------------------
28 February 2017
-------------------------------------------------------------------
There is a list with integers in range 1..n with length n+1 elements. Find the repeated element (in least space without hash tables)

Brute force requires O(n) space and hash tables require O(n) space too. This list has a pattern that all elements are in range 1..n with one repeat. Sum of this list can be computed in O(logN) space - single counter incremented - which is Total = n(n+1)/2 + repeating_element.  Total - n(n+1)/2 is the repeating element. Any other value of |Total - n(n+1)/2| which is not in 1..n indicates more than one repeating element and more than 1 repetition per repeating element. For arbitrary length of list, and multiple repetitive elements, this problem reduces to Element Distinctness Problem which has non-trivial algorithms (NlogN lowerbound with sorting, decision tree model, property testing, quantum etc.,).

-------------------------------------------------------------------
6 March 2017
-------------------------------------------------------------------
Types of Latches and FlipFlops:

SR latch (Set-Reset):
S   R   Q
1   0   1
0   1   0

JK Latch(SR Latch with Toggle Q and !Q states for 00 and 11):
J   K   Q
1   0   1
0   1   0

D FlipFlop:
D   Q
0   0
1   1

--------------------------------------------------------------------------------------------------------
20 September 2017
--------------------------------------------------------------------------------------------------------
Bernoulli Trials and Geometric Distribution:
--------------------------------------------
Question: While tossing a coin what is the expected number of coin tosses before Head appears? (i.e expected number of failures before success)

Answer: Probability of head = Pr(H) = 1/2.
Let N be the number of coin tosses before Head appears. N is a Bernoulli trial random variable.
Pr(N) is the probability of Head appearing after N coin tosses.
Pr(N) = (1-Pr(H))^(N-1)*Pr(H) (first N-1 tosses is streak of Tails and Nth toss is Head i.e TTTTT...TH)
Expected value of N = E(N) = sum_1_to_infinity(N*(1-Pr(H))^(N-1)*Pr(H)) = (1/2) + (1/2)^2 + (1/2)^3 + .... = 1/1-0.5 = 2 = (1-Pr(H))/Pr(H)
Expected value of N = (1-Pr(H))/Pr(H) = 0.5/0.5 = 1

This problem has applications in predicting binary streams of 0s and 1s in network traffic. But probability of 1 and 0 need not be a fair
coin toss i.e Pr(1) != Pr(0). If a network packet traffic stream has Pr(1) = 0.75 and Pr(0) = 0.25, Expected number of bits after which
bit 1 appears = (1-0.75)/0.75 = 1/3 and Expected number of bits before 0 appears = (1-0.25)/0.25 = 3

It has to be noted that Expectation of Appearance of Head and Expectation of Failures before Head Appears are two different random variables.

Reference: https://en.wikipedia.org/wiki/Geometric_distribution

------------------------------------------------------------------------------------------------------------------
13 October 2017
------------------------------------------------------------------------------------------------------------------
How can all nodes of same level in a binary tree be retrieved (of least time complexity)?
------------------------------------------------------------------------------------------------------------------
Assuming array representation of a binary tree, each node of the array of size 2^(logN) for N tree nodes is filled from the tree top-down and left-right and missing nodes are blank in array. In this array representation, nodes of level l are the consecutive nodes from indices 2^(l-1) to (2^l) - 1 and can be printed by iterating through array.

------------------------------------------------------------------------------------------------------------------
27 November 2017
------------------------------------------------------------------------------------------------------------------
How can a hashmap be inverted i.e keys and values are interchanged?
------------------------------------------------------------------------------------------------------------------
If the hashmap is perfect hash function, there are programming language supports e.g bidirectional dictionaries - bidict in Python, Ruby Hash#invert - http://ruby-doc.org/core-1.9.3/Hash.html#method-i-invert. If the hashmap is not perfect and has collisions each key is mapped to multiple values. Inverting this amounts to unwinding each of the collision buckets as keys and map them to the erstwhile key as value. Bruteforce algorithm is O(N) time where N is total number of values in the map. An alternative version of this problem is : Given a value v in the map find the key k which maps to v. Theoretically, this problem is parallel to Proving existence of One Way Function which is defined as Probability[f(finverse(y))==y] < epsilon for a function f and its inverse. For a hashmap H, this is equivalently stated as Probability[H(Hinverse(v))=v] where Hinverse is hashmap inverted. Difference is Function has unique range value per domain key while a hashmap has multiple values. Sublinear parallel algorithm to invert a hashmap which is not perfect could be as below:
	for each key k in hashmap H1 accessed in parallel
	{
		each element v=H1[k] in collision bucket is accessed in parallel and added as key in a new hashmap H2 as H2[v] = k
	}
Both keys and buckets are accessed in parallel. Theoretically if hashmap is on a PRAM, previous algorithm is O(1) parallel time and requires
O(N) PRAMs.

-------------------------------------------------------------------------------------------------------------------
2 January 2018 - Find Sum of Bit differences (Distance) between all possible pairs of integers in an array
-------------------------------------------------------------------------------------------------------------------
Example: For array [1,2,3] sum of bit differences for pairs:
       distance(1,2) = 01,10 = 2
       distance(1,3) = 01,11 = 1
       distance(2,3) = 10,11 = 1
                       --------
                           4
                       --------

Trivial bruteforce algorithm has to compute all possible pairs and find the distance of each pair which is O(NC2*logM) where N is the size of array and M is the largest integer in array.

Following algorithm finds the bit distance sum in O(logM*N) time for all pairs of subsets better than above bruteforce:
-----------------------------------------------------------------------------------------------------------------------
       (#) Represent the array of size N and largest number M as N * logM 2-dimensional array.
       (#) For each column (O(logM)):
       {
               Find the number of rows R having same bits - 0 or 1 (O(N)).
               /*
                       Number of pairs differing in this bit position are :
                       Set of all possible pairs - (Set of all possible pairs having both 1s + Set of all possible pairs having both 0s)
                       This contributes to the sum of distances for all bits
               */
               BitDifferenceSum += NCR-((N-R)CR + RCR)
       }

Following example executes above algorithm for array: [5,6,7,8,10] represented as 5*ceil(log10) 2-dimensional array - there are 5C2=10 possible sets of pairs:
       0101
       0110
       0111
       1000
       1010
       ---------------------
       2+1+3+4+1+3+2+4+3+1=24
       ---------------------
       There 3C2+2C2 pairs of (1,1) and (0,0) which are subtracted:
       5C2-(3C2+2C2) + 5C2-(3C2+2C2) + 5C2-(3C2+2C2) + 5C2-(3C2+2C2) = 10-4 + 10-4 + 10-4 + 10-4 = 6+6+6+6 = 24
